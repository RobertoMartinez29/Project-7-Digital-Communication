#include <msp430.h>

#define GreenLED BIT6
#define RedLED   BIT0

volatile char letter;
volatile char letterFlag = 0;
volatile char done = 1;
volatile char LED_ON = 0;
volatile char green = 0;


void main(void)
{
  WDTCTL = WDTPW | WDTHOLD;

  BCSCTL1 = CALBC1_1MHZ;  // adjust the clock
  DCOCTL = CALDCO_1MHZ;

  P1DIR |= GreenLED | RedLED;
  P1OUT &= (0x00);
  P1SEL |= BIT1 | BIT2; 
  P1SEL2 |= BIT1 | BIT2;

  TACCR0 = 65000;
  TA0CCTL0 = CCIE;
  TACTL = TASSEL_2 + MC_0;

  UCA0CTL1 |=UCSWRST | UCSSEL_2;  // settup the UART mode
  // Enable SW reset, use SMCLK

  UCA0BR0 = 104; // low bit of UCBRx is 104;
  UCA0BR1 = 0;   // high bit of UCBRx is 0;
  UCA0MCTL = UCBRS_1;
  // second modulation stage select is 1
  // boud rate = 9600

  UCA0CTL1 &= ~UCSWRST;
  //Clear SW reset, resume operation

  IE2 |= UCA0RXIE; //enable interrupt

  _enable_interrupt();

  while (1)
  {
    if (letterFlag)
    {

      done = 0;
      letterFlag = 0;

      switch (letter)
      {
        case 'g':
          P1OUT |= GreenLED;
          green = 1;
          TAR = 0;
          TACTL = TASSEL_2 + MC_1;
          break;


        case 'r':
          green = 0;
          P1OUT |= RedLED;
          TAR = 0;
          TACTL = TASSEL_2 + MC_1;
          break;

        default:
          break;
      }
    }

    if (done)
    {
      LPM1;
    }
  }
}

#pragma vector=USCIAB0RX_VECTOR
__interrupt void USCI0RX__ISR(void)
{
  letter = UCA0RXBUF;
  letterFlag = 1;
  __bic_SR_register_on_exit(LPM1_bits);
}

#pragma vector = TIMER0_A0_VECTOR
__interrupt void TimerA (void)
{
  if (green)
  {
    P1OUT &= ~GreenLED;
  }

  else 
  {
    P1OUT &= ~RedLED;
  }

  done = 1;
  TACTL = TASSEL_2 + MC_0;
}
